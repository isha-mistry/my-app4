// Superposition Bridge Hook
// Generated by Cradle - https://cradle-web-eight.vercel.app

'use client';

import { useState, useCallback } from 'react';
import { useAccount, usePublicClient, useWalletClient } from 'wagmi';
import type { Address } from 'viem';
import { createLiFi, getRoutes, executeRoute } from '@lifi/sdk';
import type { BridgeQuote, BridgeStatus, BridgeToken, SourceChain } from '../types/bridge';

// Superposition chain ID
const SUPERPOSITION_CHAIN_ID = 55244;

// Source chain IDs
const CHAIN_IDS: Record<SourceChain, number> = {
  arbitrum: 42161,
};

// Token addresses per chain (example - update with actual addresses)
const TOKEN_ADDRESSES: Record<SourceChain, Record<BridgeToken, Address>> = {
  arbitrum: {
    ETH: '0x0000000000000000000000000000000000000000' as Address,
    USDC: '0x0000000000000000000000000000000000000000' as Address,
  },
};

// Initialize Li.Fi SDK
const lifi = createLiFi({
  integrator: 'cradle-superposition-bridge',
});

export interface UseBridgeOptions {
  onSuccess?: (txHash: string) => void;
  onError?: (error: Error) => void;
}

/**
 * Hook for bridging assets to Superposition
 */
export function useSuperpositionBridge(options: UseBridgeOptions = {}) {
  const { address } = useAccount();
  const publicClient = usePublicClient();
  const { data: walletClient } = useWalletClient();

  const [status, setStatus] = useState<BridgeStatus>('idle');
  const [quote, setQuote] = useState<BridgeQuote | null>(null);
  const [error, setError] = useState<Error | null>(null);
  const [txHash, setTxHash] = useState<string | null>(null);

  /**
   * Get a bridge quote
   */
  const getQuote = useCallback(
    async (
      sourceChain: SourceChain,
      token: BridgeToken,
      amount: bigint
    ): Promise<BridgeQuote | null> => {
      if (!address) {
        setError(new Error('Wallet not connected'));
        return null;
      }

      setStatus('fetching-quote');
      setError(null);

      try {
        const fromChainId = CHAIN_IDS[sourceChain];
        const fromToken = TOKEN_ADDRESSES[sourceChain][token];

        const routes = await getRoutes({
          fromChainId,
          toChainId: SUPERPOSITION_CHAIN_ID,
          fromTokenAddress: fromToken,
          toTokenAddress: fromToken, // Same token on destination
          fromAmount: amount.toString(),
          fromAddress: address,
          toAddress: address,
          options: {
            slippage: 0.005, // 0.5% slippage
            order: 'RECOMMENDED',
          },
        });

        if (!routes.routes || routes.routes.length === 0) {
          throw new Error('No routes found for this bridge');
        }

        const bestRoute = routes.routes[0];
        const bridgeQuote: BridgeQuote = {
          fromChainId,
          toChainId: SUPERPOSITION_CHAIN_ID,
          fromToken,
          toToken: fromToken,
          fromAmount: amount,
          toAmount: BigInt(bestRoute.toAmount),
          estimatedGas: BigInt(bestRoute.gasCostUSD || '0'),
          bridgeFee: BigInt(0), // Extract from route if available
          route: {
            provider: bestRoute.steps[0]?.toolDetails?.name || 'Unknown',
            steps: bestRoute.steps.map(step => ({
              type: step.type as 'swap' | 'bridge' | 'approve',
              tool: step.tool,
              fromChain: step.action.fromChainId,
              toChain: step.action.toChainId,
              fromToken: step.action.fromToken.address as Address,
              toToken: step.action.toToken.address as Address,
              fromAmount: step.action.fromAmount,
              toAmount: step.estimate.toAmount,
            })),
            estimatedTime: bestRoute.steps.reduce(
              (acc, step) => acc + (step.estimate.executionDuration || 0),
              0
            ),
          },
        };

        setQuote(bridgeQuote);
        setStatus('idle');
        return bridgeQuote;
      } catch (err) {
        const error = err instanceof Error ? err : new Error('Failed to get quote');
        setError(error);
        setStatus('error');
        options.onError?.(error);
        return null;
      }
    },
    [address, options]
  );

  /**
   * Execute bridge transaction
   */
  const bridge = useCallback(
    async (
      sourceChain: SourceChain,
      token: BridgeToken,
      amount: bigint
    ): Promise<string | null> => {
      if (!address || !walletClient) {
        setError(new Error('Wallet not connected'));
        return null;
      }

      try {
        // Get fresh quote
        const bridgeQuote = await getQuote(sourceChain, token, amount);
        if (!bridgeQuote) return null;

        setStatus('bridging');

        // Execute the route via Li.Fi
        const fromChainId = CHAIN_IDS[sourceChain];
        const fromToken = TOKEN_ADDRESSES[sourceChain][token];

        const routes = await getRoutes({
          fromChainId,
          toChainId: SUPERPOSITION_CHAIN_ID,
          fromTokenAddress: fromToken,
          toTokenAddress: fromToken,
          fromAmount: amount.toString(),
          fromAddress: address,
          toAddress: address,
        });

        if (!routes.routes || routes.routes.length === 0) {
          throw new Error('No routes found');
        }

        const result = await executeRoute(routes.routes[0], {
          // Signer will be obtained from wallet
        });

        setTxHash(result.transactionHash || null);
        setStatus('waiting-confirmation');

        // Wait for confirmation
        setStatus('completed');
        options.onSuccess?.(result.transactionHash || '');

        return result.transactionHash || null;
      } catch (err) {
        const error = err instanceof Error ? err : new Error('Bridge failed');
        setError(error);
        setStatus('error');
        options.onError?.(error);
        return null;
      }
    },
    [address, walletClient, getQuote, options]
  );

  /**
   * Reset bridge state
   */
  const reset = useCallback(() => {
    setStatus('idle');
    setQuote(null);
    setError(null);
    setTxHash(null);
  }, []);

  return {
    // State
    status,
    quote,
    error,
    txHash,
    isLoading: status === 'fetching-quote' || status === 'bridging' || status === 'waiting-confirmation',
    
    // Actions
    getQuote,
    bridge,
    reset,
    
    // Config
    supportedTokens: ["ETH","USDC"] as const,
    sourceChains: ["arbitrum"] as const,
  };
}